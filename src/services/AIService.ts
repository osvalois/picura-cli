import { Configuration, OpenAIApi } from 'openai';
import { DocumentType } from '@prisma/client';
import { LoggingService } from './LoggingService';

export class AIService {
  private openai: OpenAIApi;
  private logger: LoggingService;

  constructor(logger: LoggingService) {
    const configuration = new Configuration({
      apiKey: process.env.OPENAI_API_KEY,
    });
    this.openai = new OpenAIApi(configuration);
    this.logger = logger;
  }

  async generateDocumentContent(type: DocumentType, projectStructure: string): Promise<string> {
    try {
      this.logger.info(`Generating document content for type: ${type}`);
      const prompt = this.getPromptForDocumentType(type, projectStructure);
      
      const response = await this.openai.createChatCompletion({
        model: 'gpt-3.5-turbo',
        messages: [
          { role: 'system', content: 'You are a helpful assistant that generates software documentation.' },
          { role: 'user', content: prompt }
        ],
        max_tokens: 2000,
        temperature: 0.7,
      });

      if (!response.data.choices[0].message?.content) {
        throw new Error('No content generated by AI');
      }

      const formattedContent = this.formatGeneratedContent(type, response.data.choices[0].message.content);
      this.logger.info(`Document content generated successfully for type: ${type}`);
      return formattedContent;
    } catch (error: any) {
      this.logger.error(`Failed to generate document content for type: ${type}`, { 
        error: error.message,
        response: error.response?.data
      });
      throw new Error(`Failed to generate document: ${error.message}`);
    }
  }

  private getPromptForDocumentType(type: DocumentType, projectStructure: string): string {
    const basePrompt = `Given the following project structure:\n\n${projectStructure}\n\n`;

    switch (type) {
      case DocumentType.ARCHITECTURE:
        return `${basePrompt}Generate a comprehensive software architecture document. Include sections on system overview, component descriptions, data flow, and technology stack. Use markdown formatting.`;
      case DocumentType.DATA_SCHEMA:
        return `${basePrompt}Generate a detailed data schema document. Include entity relationships, data types, and any relevant database design considerations. Use markdown formatting and include example schemas where appropriate.`;
      case DocumentType.API_SPECIFICATION:
        return `${basePrompt}Create an API specification document. Detail endpoints, request/response formats, authentication methods, and any API design patterns used. Use markdown formatting and include example requests and responses.`;
      case DocumentType.USER_MANUAL:
        return `${basePrompt}Write a user manual for the software. Cover installation, configuration, basic usage, and any important features or functionality. Use markdown formatting and include screenshots or diagrams where appropriate.`;
      case DocumentType.DEPLOYMENT:
        return `${basePrompt}Create a deployment plan document. Include steps for environment setup, build process, deployment procedure, and any post-deployment checks or monitoring. Use markdown formatting and include any necessary scripts or commands.`;
      default:
        throw new Error(`Unsupported document type: ${type}`);
    }
  }

  private formatGeneratedContent(type: DocumentType, content: string): string {
    const title = `# ${type.charAt(0).toUpperCase() + type.slice(1).toLowerCase()} Document\n\n`;
    const toc = '## Table of Contents\n\n';
    
    const headers = content.match(/^##\s.+$/gm) || [];
    const tocContent = headers.map(header => {
      const text = header.replace(/^##\s/, '');
      const link = text.toLowerCase().replace(/\s/g, '-');
      return `- [${text}](#${link})`;
    }).join('\n');

    return `${title}${toc}${tocContent}\n\n${content}`;
  }
}